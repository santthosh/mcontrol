# Mission Control — Monorepo Bootstrap Spec

## Context

Mission Control is a desktop app for managing long-running AI agents — think "Superhuman for AI agents." This is the Phase 0 bootstrap task: set up the monorepo so all subsequent R1a work (the core dispatch→triage→review loop) has a working foundation.

**After this task, a developer should be able to clone, run `make dev`, and have a working Tauri desktop window talking to a FastAPI backend — within 5 minutes.**

---

## Repo Structure

```
mcontrol/
├── apps/
│   ├── desktop/          # Tauri v2 shell (Rust) + React frontend
│   └── api/              # FastAPI service (Python 3.12+)
├── packages/
│   └── shared/           # Shared schemas, types, constants
├── docs/                 # Architecture, API spec, ADRs
├── infra/                # Docker Compose, GCP config placeholders
├── docker-compose.yml    # Local dev: Postgres 16 + Redis 7
├── Makefile              # Top-level dev commands
└── README.md
```

Use **pnpm workspaces** as the workspace manager. Turborepo optional but not required for bootstrap.

---

## 1. Desktop App — `apps/desktop/`

**Stack:** Tauri v2 + React 18 + TypeScript + Vite + Tailwind CSS

### Setup
- Initialize a Tauri v2 project with Rust backend and React+TS webview
- Vite as the bundler inside the Tauri webview
- Tailwind CSS configured and producing styles

### Folder structure
```
apps/desktop/
├── src-tauri/            # Rust/Tauri backend
│   ├── src/
│   │   └── main.rs
│   ├── Cargo.toml
│   ├── tauri.conf.json
│   └── capabilities/     # Tauri v2 capability declarations
├── src/                  # React frontend
│   ├── components/
│   ├── pages/
│   ├── hooks/
│   ├── lib/
│   ├── styles/
│   ├── App.tsx
│   └── main.tsx
├── index.html
├── package.json
├── tsconfig.json
├── vite.config.ts
└── tailwind.config.ts
```

### Tauri Capabilities
Declare these in Tauri v2 capabilities config:
- **HTTP client** — fetch to API (`localhost:8000` dev, `https://api.mcontrol.ai` prod)
- **WebSocket** — real-time connection to API
- **OS keychain access** — for encrypted API key storage later

### Landing Screen
Render a minimal landing screen showing:
- App name: "Mission Control"
- Connection status indicator: **green** when `GET /api/health` succeeds, **red** when unreachable
- Poll health endpoint every 5 seconds

### Build Commands
- `pnpm --filter desktop dev` → starts Tauri in dev mode with HMR on React layer
- `pnpm --filter desktop build` → produces macOS `.dmg` or `.app` binary

---

## 2. Cloud API — `apps/api/`

**Stack:** Python 3.12+, FastAPI, SQLAlchemy + Alembic, PostgreSQL, Redis, uvicorn

### Folder structure
```
apps/api/
├── app/
│   ├── __init__.py
│   ├── main.py           # FastAPI app factory
│   ├── routes/           # API route modules
│   │   └── health.py
│   ├── services/         # Business logic
│   ├── models/           # SQLAlchemy models
│   ├── middleware/        # Auth, CORS, etc.
│   └── lib/              # Utilities, config
├── tests/
│   └── test_health.py
├── alembic/              # Database migrations
│   └── versions/
├── alembic.ini
├── pyproject.toml        # Python deps + tool config
├── Dockerfile            # Multi-stage, Cloud Run ready
├── .env.example
└── requirements.txt      # Or use pyproject.toml [project.dependencies]
```

### Endpoints to implement
1. **Health check:** `GET /api/health` → `{ "status": "ok", "version": "0.0.1" }`
2. **WebSocket stub:** `ws://localhost:8000/api/ws` → accepts connection, sends heartbeat ping every 30s

### Database
- PostgreSQL via SQLAlchemy (async)
- Alembic for migrations
- Initial migration: create database baseline schema (just a `users` table, empty)
- Connection string from env var `DATABASE_URL`

### Auth (stubbed)
- Firebase Auth middleware: reads JWT from `Authorization: Bearer <token>` header
- Validates against Firebase project (configurable)
- **Dev bypass:** when `AUTH_DISABLED=true` env var is set, skip validation entirely and use a mock user. This is the default for local dev.

### Environment
- `.env.example` committed with keys: `DATABASE_URL`, `REDIS_URL`, `FIREBASE_PROJECT_ID`, `AUTH_DISABLED`
- No secrets in repo

### Build Commands
- `uvicorn app.main:app --reload --port 8000` for dev
- `Dockerfile`: multi-stage build, production-ready for Cloud Run

### Tests
- pytest + httpx for async endpoint testing
- At minimum: test that `/api/health` returns 200 with expected body

---

## 3. Shared Schemas — `packages/shared/`

### Approach
Define schemas in **TypeScript (Zod)** as the source of truth. Provide a codegen or mirror script to produce **Pydantic models** for the Python API.

Alternatively: use JSON Schema as the neutral format and generate both Zod and Pydantic from it. Pick whichever is simpler to set up — the key constraint is that **both apps consume the same schema definitions**.

### Core Types

```typescript
// Task
interface Task {
  id: string
  user_id: string
  team_member_id: string
  model_id: string
  prompt: string
  status: TaskStatus
  context_attachments: string[]
  created_at: string    // ISO 8601
  started_at: string | null
  completed_at: string | null
  cost: number | null
  tokens_used: number | null
}

// TeamMember
interface TeamMember {
  id: string
  name: string
  avatar_url: string
  system_prompt: string
  default_model_id: string
  bio: string
}

// Model
interface Model {
  id: string
  provider: Provider
  name: string
  display_name: string
  capabilities: string[]
}

// Credential
interface Credential {
  id: string
  user_id: string
  provider: Provider
  created_at: string
  updated_at: string
}

// UserSettings
interface UserSettings {
  id: string
  user_id: string
  autonomy_level: AutonomyLevel
}
```

### Core Enums

```typescript
enum TaskStatus {
  queued = "queued",
  running = "running",
  awaiting_review = "awaiting_review",
  approved = "approved",
  revision_requested = "revision_requested",
  cancelled = "cancelled",
  failed = "failed"
}

enum AutonomyLevel {
  full_auto = "full_auto",
  supervised = "supervised",
  manual = "manual"
}

enum Provider {
  anthropic = "anthropic",
  openai = "openai",
  google = "google"
}
```

### Validation
Changing a shared schema should trigger type errors in both the desktop app (TS compile) and the API (Pydantic validation) if not updated in both places.

---

## 4. Docs — `docs/`

Create the following files with real content:

| File | Content |
|---|---|
| `README.md` (repo root) | Project overview + quickstart: clone → `make dev` → working app |
| `docs/ARCHITECTURE.md` | System diagram: Tauri client → WS + REST → FastAPI on Cloud Run → Postgres + Redis + LLM providers. Map GCP services: Cloud SQL, Firebase Auth, Memorystore Redis, Cloud Run |
| `docs/API.md` | Placeholder API reference with section headers: Auth, Keys, Tasks, Team Members, Settings, Models, WebSocket |
| `docs/ADR/001-tauri-cloud-run-monorepo.md` | Decision record: why Tauri + Cloud Run monorepo |
| `docs/ADR/002-python-fastapi.md` | Decision record: why Python/FastAPI for the API |
| `docs/CONTRIBUTING.md` | How to: set up local dev, run migrations, add a new endpoint, build the desktop app |

---

## 5. Infrastructure — `infra/`

### docker-compose.yml (repo root)
```yaml
services:
  postgres:
    image: postgres:16
    ports: ["5432:5432"]
    environment:
      POSTGRES_DB: mcontrol
      POSTGRES_USER: mcontrol
      POSTGRES_PASSWORD: mcontrol
    volumes:
      - pgdata:/var/lib/postgresql/data

  redis:
    image: redis:7
    ports: ["6379:6379"]

volumes:
  pgdata:
```

### Placeholder files
- `infra/clouddeploy/` — Cloud Run service YAML + `gcloud run deploy` script (placeholder)
- `infra/sql/` — initial migration SQL (baseline schema)
- `infra/firebase/` — Firebase project config placeholder (project ID, auth settings)
- `infra/secrets.example` — documents which GCP Secret Manager keys are needed for prod

---

## 6. Makefile — Dev Commands

All commands should work from repo root:

| Command | What it does |
|---|---|
| `make dev` | Starts docker-compose (Postgres + Redis) + API server + Tauri desktop app |
| `make dev-api` | Starts docker-compose + API server only |
| `make dev-desktop` | Starts Tauri desktop app only (expects API already running) |
| `make build` | Builds all packages in dependency order |
| `make test` | Runs all tests: pytest for API, Vitest for desktop |
| `make lint` | Runs ruff (Python) + ESLint (TypeScript) |
| `make typecheck` | Runs mypy/pyright (Python) + tsc --noEmit (TypeScript) |

---

## 7. Toolchain & Config Files

| File | Purpose |
|---|---|
| `.gitignore` | `node_modules`, `dist`, `target/` (Rust), `.env`, `__pycache__`, `.DS_Store`, IDE files |
| `.nvmrc` | `22` (Node.js 22 LTS) |
| `rust-toolchain.toml` | Pin stable Rust version for Tauri builds |
| `pyproject.toml` | Python 3.12+ specified |
| `.github/workflows/ci.yml` | GitHub Actions: install Node + Python + Rust, run lint + typecheck + test for both apps |

---

## Definition of Done

1. **5-minute quickstart:** Clone → `make dev` → Postgres + Redis running in Docker, `localhost:8000/api/health` returns OK, Tauri desktop window shows green connection status
2. **Shared schemas work:** Importable in both Python API (Pydantic) and TypeScript desktop app (Zod) without errors
3. **All checks pass:** `make lint`, `make typecheck`, `make test` all pass with zero errors on a clean clone
4. **Architecture matches vision:** Tauri thin client → REST + WebSocket → FastAPI on Cloud Run → Postgres + Redis

---

## What NOT to build

This is strictly scaffolding. Do **not** implement:
- Any UI beyond the landing/connection-status screen
- Any API routes beyond `/api/health` and the WebSocket stub
- Any LLM provider integration
- Any real authentication flow (just the middleware stub with dev bypass)
- Any database tables beyond the baseline `users` table
- Any CI deployment pipelines (just the CI test workflow)