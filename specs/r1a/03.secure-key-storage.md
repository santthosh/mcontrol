# Secure Key Storage & Encryption at Rest

## Context

Mission Control needs to store user-provided API keys (Anthropic, OpenAI, Google AI, etc.) so that long-running agents can make outbound LLM calls on the user's behalf. Keys are highly sensitive — a leak exposes billing and data. This task implements encrypted credential storage in Firestore so that plaintext keys are never persisted and are only decrypted in-memory at the moment of an outbound LLM call.

**After this task, users can add/view/update/delete their API keys through the desktop app. Keys are AES-256-GCM encrypted before being written to Firestore. The API never returns full plaintext keys — only masked suffixes for display.**

---

## Architecture: Per-User Encrypted Subcollections

Credentials are stored as Firestore subcollection documents under each user: `users/{uid}/credentials/{credentialId}`. Each document contains an AES-256-GCM encrypted blob of the API key, plus metadata (provider, display name, masked suffix). A single symmetric encryption key — loaded from an environment variable (local dev) or GCP Secret Manager (deployed environments) — protects all credential blobs.

```
Desktop                                         API                              Firestore
  │                                              │                                  │
  ├─ POST /api/keys { provider, name, key } ──►  │                                  │
  │                                              ├─ validate key format              │
  │                                              ├─ encrypt(key) → ciphertext        │
  │                                              ├─ extract last 4 chars → suffix    │
  │                                              ├─ store { provider, name,      ──► │
  │                                              │    encrypted_key, key_suffix }     │
  │◄── { id, provider, name, key_hint } ─────────┤                                  │
  │                                              │                                  │
  ├─ GET /api/keys ───────────────────────────►  │                                  │
  │                                              ├─ list docs ◄──────────────────────┤
  │◄── [{ id, provider, name, key_hint }] ───────┤  (never decrypt)                 │
  │                                              │                                  │
  ├─ (agent makes LLM call) ───────────────────► │                                  │
  │                                              ├─ fetch credential doc ◄───────────┤
  │                                              ├─ decrypt(encrypted_key) → key     │
  │                                              ├─ call LLM provider with key       │
  │                                              ├─ zero key from memory             │
  │                                              │  (never log plaintext)            │
```

---

## 1. Encryption Module — `apps/api/app/lib/crypto.py` (new file)

### 1.1 Algorithm

AES-256-GCM via Python's `cryptography` library. Each encryption produces a unique random 12-byte nonce. The stored blob format is:

```
nonce (12 bytes) || ciphertext || GCM tag (16 bytes)
```

The blob is base64-encoded for Firestore string storage.

### 1.2 Functions

```python
def encrypt(plaintext: str) -> str:
    """Encrypt a string with AES-256-GCM. Returns base64-encoded blob."""

def decrypt(ciphertext_b64: str) -> str:
    """Decrypt a base64-encoded AES-256-GCM blob. Returns plaintext string."""

def mask_key(key: str) -> str:
    """Return a masked display hint, e.g. 'sk-...7f3a' (prefix + last 4 chars)."""

def zero_string(s: str) -> None:
    """Best-effort zeroing of a string's underlying buffer (Python limitation noted)."""
```

### 1.3 Key Management

The encryption key is a 32-byte (256-bit) key, base64-encoded in the environment variable `CREDENTIAL_ENCRYPTION_KEY`.

- **Local dev:** Set in root `.env` file (gitignored) or `apps/api/.env`
- **Deployed:** Stored in GCP Secret Manager as `credential-encryption-key-{env}`, injected into Cloud Run as an environment variable

On startup, `crypto.py` reads and caches the decoded key. If the variable is missing, the module raises a clear error at import time rather than failing silently at encrypt/decrypt time.

---

## 2. Firestore Model — `apps/api/app/models/credential.py` (new file)

### 2.1 Document Structure

Firestore path: `users/{uid}/credentials/{credentialId}`

```python
@dataclass
class CredentialDocument(BaseDocument):
    COLLECTION = "credentials"  # subcollection name under user doc

    provider: str = ""           # "anthropic" | "openai" | "google" | "custom"
    name: str = ""               # user-chosen display name, e.g. "My Anthropic Key"
    encrypted_key: str = ""      # base64-encoded AES-256-GCM blob
    key_suffix: str = ""         # last 4 chars of plaintext key for display
```

Inherits `id`, `created_at`, `updated_at` from `BaseDocument`.

### 2.2 Subcollection Pattern

Unlike the top-level `users` collection, credentials live as a **subcollection** under each user document. The repository must reference the parent path: `users/{uid}/credentials`.

---

## 3. Credential Repository — `apps/api/app/repositories/credential.py` (new file)

Extends `BaseRepository[CredentialDocument]` but overrides the collection reference to use the user-scoped subcollection.

```python
class CredentialRepository:
    def __init__(self, db: firestore.Client, user_id: str):
        """Initialize with a Firestore client and the owning user's UID."""
        # collection_ref = db.collection("users").document(user_id).collection("credentials")

    def create(self, doc: CredentialDocument) -> CredentialDocument: ...
    def get(self, credential_id: str) -> CredentialDocument | None: ...
    def list(self, limit: int = 50) -> list[CredentialDocument]: ...
    def update(self, credential_id: str, data: dict) -> CredentialDocument | None: ...
    def delete(self, credential_id: str) -> bool: ...
```

The repository does **not** handle encryption — it stores/retrieves whatever it's given. Encryption is the responsibility of the route layer (or a service function) so the repository stays generic.

---

## 4. API Routes — `apps/api/app/routes/keys.py` (new file)

All endpoints require authentication (`CurrentUser` dependency). Keys are scoped to the authenticated user — no cross-user access is possible by design (subcollection path contains `user.uid`).

### 4.1 Endpoints

| Method | Path | Auth | Purpose |
|--------|------|------|---------|
| `POST` | `/api/keys` | Yes | Create a new API key credential |
| `GET` | `/api/keys` | Yes | List all credentials (masked — no plaintext) |
| `GET` | `/api/keys/:id` | Yes | Get a single credential (masked) |
| `PUT` | `/api/keys/:id` | Yes | Update a credential (name, key, or both) |
| `DELETE` | `/api/keys/:id` | Yes | Delete a credential (zeroes blob before removal) |

### 4.2 Request / Response Schemas

```python
class CreateKeyRequest(BaseModel):
    provider: str          # "anthropic" | "openai" | "google" | "custom"
    name: str              # display name
    key: str               # plaintext API key (only accepted on create/update, never returned)

class UpdateKeyRequest(BaseModel):
    name: str | None = None
    key: str | None = None   # if provided, re-encrypts

class KeyResponse(BaseModel):
    id: str
    provider: str
    name: str
    key_hint: str           # e.g. "sk-...7f3a"
    created_at: str
    updated_at: str
```

### 4.3 Endpoint Behavior

**POST /api/keys:**
1. Validate `key` is non-empty and >= 8 characters
2. `mask_key(key)` → `key_suffix`
3. `encrypt(key)` → `encrypted_key`
4. Generate a UUID for the credential ID
5. Store `CredentialDocument` via repository
6. Return `KeyResponse` (masked)

**GET /api/keys:**
1. List all credential documents for the user
2. Map each to `KeyResponse` using `key_suffix` — never decrypt
3. Return list

**GET /api/keys/:id:**
1. Get credential document by ID
2. Return `KeyResponse` (masked) — or 404

**PUT /api/keys/:id:**
1. Get existing document — 404 if not found
2. If `key` provided: validate, re-encrypt, update `key_suffix`
3. If `name` provided: update name
4. Update document via repository
5. Return updated `KeyResponse`

**DELETE /api/keys/:id:**
1. Get existing document — 404 if not found
2. Overwrite `encrypted_key` field with empty string (zero out the blob)
3. Delete the document
4. Return 204

### 4.4 Router Registration

Add to `apps/api/app/main.py`:
```python
from app.routes import keys
app.include_router(keys.router, prefix="/api")
```

---

## 5. Configuration Changes

### 5.1 API Config — `apps/api/app/lib/config.py`

Add to `Settings`:
```python
credential_encryption_key: str = ""  # base64-encoded 32-byte AES key
```

### 5.2 Environment — `apps/api/.env.example`

Add:
```
# Credential encryption (AES-256-GCM, base64-encoded 32-byte key)
# Generate with: python -c "import secrets,base64; print(base64.b64encode(secrets.token_bytes(32)).decode())"
CREDENTIAL_ENCRYPTION_KEY=
```

### 5.3 GCP Secret Manager — `infra/terraform/modules/mcontrol/secrets.tf`

Add a new secret resource:
```hcl
resource "google_secret_manager_secret" "credential_encryption_key" {
  secret_id = "credential-encryption-key-${var.environment}"
  ...
}
```

Add to Cloud Run environment variables in `cloud_run.tf`.

### 5.4 Makefile

No changes needed — the existing `.env` include and export pattern handles new variables automatically.

---

## 6. API Dependencies

### 6.1 Python Package

Add `cryptography` to `apps/api/requirements.txt`:
```
cryptography>=44.0.0
```

This is a well-maintained, audited library that provides AES-GCM primitives. No Firebase or Google-specific encryption SDK is needed.

---

## 7. Desktop Changes — `apps/desktop/`

### 7.1 API Client — `src/lib/api.ts`

Add authenticated API functions:

```typescript
// Credential types
interface Credential {
  id: string;
  provider: string;
  name: string;
  key_hint: string;
  created_at: string;
  updated_at: string;
}

// CRUD operations
async function createKey(provider: string, name: string, key: string): Promise<Credential>
async function listKeys(): Promise<Credential[]>
async function getKey(id: string): Promise<Credential>
async function updateKey(id: string, data: { name?: string; key?: string }): Promise<Credential>
async function deleteKey(id: string): Promise<void>
```

All use `fetchWithAuth()` which injects the Bearer token.

### 7.2 UI — Not in scope

The acceptance criteria focus on the backend storage and API layer. A full credentials management UI (settings page with add/edit/delete forms) is a separate task. However, the API client functions above should be implemented so the UI task only needs to wire up components.

---

## 8. Shared Schema Update — `packages/shared/`

### 8.1 TypeScript Schema — `packages/shared/src/schemas.ts`

The existing `Credential` schema needs no `key` field (keys are never returned in full). Verify the existing schema aligns with `KeyResponse`:

```typescript
// Existing fields: id, name, type, provider, createdAt, updatedAt
// Add if missing:
export const Credential = z.object({
  id: UUID,
  name: z.string().min(1).max(255),
  provider: Provider,
  keyHint: z.string(),           // add: masked key suffix
  createdAt: DateTimeString,
  updatedAt: DateTimeString,
});
```

Remove `type` field (credential type like "api_key" | "oauth" is not needed for this task — all credentials are API keys). Or keep it if other credential types are planned soon.

### 8.2 Pydantic Codegen

Run `pnpm --filter @mcontrol/shared generate:pydantic` after schema changes.

---

## 9. Security Considerations

### 9.1 Encryption Key Rotation

Not in scope for this task. Future work: support multiple key versions (store key version ID alongside encrypted blob), decrypt with old key, re-encrypt with new key.

### 9.2 Python String Zeroing Limitation

Python strings are immutable — true zeroing is not possible at the language level. The `zero_string` helper does a best-effort `ctypes` overwrite of the string buffer, but this is acknowledged as a mitigation, not a guarantee. The key mitigation is that plaintext keys exist in memory only for the duration of a single request (encrypt on store, decrypt on LLM call).

### 9.3 Logging

Ensure no route, middleware, or exception handler logs request bodies for key endpoints. FastAPI's default exception handler should not leak `CreateKeyRequest.key` in error responses. Use `key: SecretStr` from Pydantic if additional safety is desired.

### 9.4 Transport Security

All deployed environments use HTTPS (Cloud Run enforces it). Local dev uses HTTP but is localhost-only.

---

## 10. Tests — `apps/api/tests/test_keys.py` (new file)

### 10.1 Unit Tests (no Firestore required)

| Test | What it verifies |
|------|-----------------|
| `test_encrypt_decrypt_roundtrip` | `decrypt(encrypt(key)) == key` for various key formats |
| `test_encrypt_produces_unique_ciphertext` | Two encryptions of the same plaintext produce different blobs (unique nonce) |
| `test_mask_key_format` | `mask_key("sk-abc123def456")` → `"sk-...f456"` |
| `test_mask_key_short` | Short keys (< 8 chars) are rejected |
| `test_decrypt_wrong_key_fails` | Decrypting with a different encryption key raises error |
| `test_decrypt_corrupted_blob_fails` | Tampered ciphertext raises error |

### 10.2 Integration Tests (with Firestore emulator)

| Test | What it verifies |
|------|-----------------|
| `test_create_key` | POST returns 201 with masked `key_hint`, stores encrypted blob |
| `test_list_keys_masked` | GET returns list with `key_hint`, no plaintext key field |
| `test_get_key_masked` | GET /:id returns single credential, masked |
| `test_update_key` | PUT updates name and/or re-encrypts key |
| `test_delete_key` | DELETE returns 204, subsequent GET returns 404 |
| `test_create_key_empty_rejected` | POST with empty key returns 422 |
| `test_cross_user_isolation` | User A cannot see/modify User B's keys |
| `test_unauthenticated_rejected` | All endpoints return 401 without Bearer token |

---

## File Summary

### New Files

| File | Purpose |
|------|---------|
| `apps/api/app/lib/crypto.py` | AES-256-GCM encrypt/decrypt, key masking |
| `apps/api/app/models/credential.py` | Firestore document model |
| `apps/api/app/repositories/credential.py` | User-scoped subcollection CRUD |
| `apps/api/app/routes/keys.py` | REST endpoints for credential management |
| `apps/api/tests/test_keys.py` | Unit + integration tests |

### Modified Files

| File | Change |
|------|--------|
| `apps/api/app/lib/config.py` | Add `credential_encryption_key` setting |
| `apps/api/app/main.py` | Register keys router |
| `apps/api/.env.example` | Add `CREDENTIAL_ENCRYPTION_KEY` |
| `apps/api/requirements.txt` | Add `cryptography` |
| `apps/desktop/src/lib/api.ts` | Add credential CRUD API functions |
| `packages/shared/src/schemas.ts` | Add `keyHint` to Credential schema |
| `infra/terraform/modules/mcontrol/secrets.tf` | Add encryption key secret |
| `infra/terraform/modules/mcontrol/cloud_run.tf` | Inject encryption key env var |

---

## Definition of Done

1. **Encryption works:** `encrypt → store → retrieve → decrypt` round-trip produces the original key
2. **Keys never stored in plaintext:** Firestore documents contain only the AES-256-GCM encrypted blob
3. **GET never leaks keys:** All GET responses return `key_hint` (e.g. `sk-...7f3a`), never the full key
4. **Per-user isolation:** User A cannot access User B's credentials (enforced by subcollection path)
5. **Delete zeroes blob:** Deleting a key overwrites the encrypted field before removing the document
6. **Validation enforced:** Empty and malformed keys are rejected at the API layer
7. **All checks pass:** `make lint`, `make typecheck`, `make test` pass with zero errors

---

## What NOT to build

- Credentials management UI (settings page, forms) — separate task
- Encryption key rotation mechanism
- Client-side encryption or OS keychain integration
- Rate limiting on key endpoints
- Key usage tracking or audit logging
- Support for OAuth or service account credential types (API keys only for now)
- Automatic key validation against provider APIs
